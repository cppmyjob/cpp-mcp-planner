# Repository Pattern Architecture Plan v3.4

> Sprint 9: Universal Storage Abstraction for cpp-mcp-planner
>
> **Version:** 3.4 (Comprehensive Review - 31 Issues Fixed)
> **Last Updated:** 2025-12-07
> **Changes:** v3.4 comprehensive review fixes:
> - CR-C1 to CR-C4: Entity field alignment, IndexMetadata schedule fields, JSON columns completeness
> - CR-H1 to CR-H6: Deprecation notes, truncation docs, slug generation, CreateInput docs
> - CR-M1 to CR-M4: lockVersion clarification, VersionHistory design docs, QueryOptions limits, blockers vs blockingReason
> - CR-L1 to CR-L9: Complete enum values, helper types documentation
> - CR-A1 to CR-A5: SQL JSON queries, index recommendations, scalability, integrity checks

## Executive Summary

This document describes the architecture for introducing the Repository Pattern to support multiple storage backends (File, SQLite, PostgreSQL, MongoDB) with a unified interface.

### Current Problems

| Issue | Impact |
|-------|--------|
| All entities of one type in single file | Poor scalability (1000+ entities = 5MB file) |
| Full file rewrite on each update | O(n) write operations |
| Direct FileStorage dependency | Cannot switch storage backends |
| Concurrent write conflicts | Data corruption risk |

### Proposed Solution

- **Repository Pattern** with generic `Repository<T>` interface
- **File-per-entity** storage strategy with indexes
- **Unit of Work** pattern for transactions
- **Factory Pattern** for storage backend selection

---

## 1. Core Interfaces

### 1.1 Using Existing Entity Interface

**IMPORTANT:** We use the existing `Entity` interface from `src/domain/entities/types.ts` instead of creating a new one:

```typescript
// src/domain/entities/types.ts (EXISTING - DO NOT MODIFY)
export interface Entity {
  id: string;
  type: EntityType;
  createdAt: string;
  updatedAt: string;
  version: number;
  metadata: {
    createdBy: string;
    tags: Tag[];
    annotations: Annotation[];
  };
}
```

### 1.2 Repository Interfaces

```typescript
// src/domain/repositories/interfaces.ts

import {
  Entity,
  EntityType,
  Requirement,
  Solution,
  Decision,
  Phase,
  Artifact,
  Link,
  RelationType,  // FIX H3: Import for type-safe link queries
  Tag
} from '../entities/types.js';

// ============================================================================
// Query Types
// ============================================================================

/**
 * Type constraint for comparison operators
 * Only number, string, and Date can use $gt, $gte, $lt, $lte
 */
type Comparable = number | string | Date;

/**
 * Filter operators for SQL-compatible queries
 * FIX C1: Type-constrained comparison operators prevent invalid usage
 */
export interface FilterOperators<T> {
  $eq?: T;
  $ne?: T;
  $in?: T[];
  $nin?: T[];
  // Comparison ops only for comparable types (reject arrays/objects at compile-time)
  $gt?: T extends Comparable ? T : never;
  $gte?: T extends Comparable ? T : never;
  $lt?: T extends Comparable ? T : never;
  $lte?: T extends Comparable ? T : never;
  $contains?: T extends string ? string : never;  // For string fields only
}

/**
 * Type-safe filter definition
 * Supports both simple equality and operator-based filters
 *
 * FIX C1: LIMITATION - Nested object filtering NOT supported
 * Filter only works on TOP-LEVEL fields. Cannot filter by:
 * - metadata.createdBy
 * - evaluation.effortEstimate
 * - source.type
 * - schedule.estimatedEffort
 *
 * For nested field filtering:
 * - Load entities and filter in application code
 * - Future: Add dot-notation support for SQL backends (e.g., "metadata.createdBy")
 */
export type Filter<T> = {
  [K in keyof T]?: T[K] | FilterOperators<T[K]>;
};

/**
 * Query options with filtering, sorting, and pagination
 */
export interface QueryOptions<T> {
  filter?: Filter<T>;
  sort?: Array<{ field: keyof T; order: 'asc' | 'desc' }>;
  pagination?: { limit: number; offset: number };
  fields?: (keyof T)[];  // Projection - select specific fields
}

/**
 * Query result with pagination metadata
 */
export interface QueryResult<T> {
  data: T[];
  total: number;
  hasMore: boolean;
}

// ============================================================================
// Create Input Types
// ============================================================================

/**
 * Fields that are auto-generated and should be omitted from create input
 */
type AutoGeneratedFields = 'id' | 'type' | 'createdAt' | 'updatedAt' | 'version';

/**
 * Create input type - excludes auto-generated fields, allows optional tags
 *
 * FIX CR-H5: Metadata handling on create:
 * - `createdBy` is auto-set to 'claude-code' by FileRepository
 * - `tags` can be provided via CreateInput (defaults to [])
 * - `annotations` always starts as [] (add via update operations)
 */
export type CreateInput<T extends Entity> = Omit<T, AutoGeneratedFields | 'metadata'> & {
  tags?: Tag[];
};

// ============================================================================
// Read Repository Interface (Query operations)
// ============================================================================

export interface ReadRepository<T extends Entity> {
  /**
   * Find entity by ID
   * @returns Entity or null if not found
   */
  findById(id: string): Promise<T | null>;

  /**
   * Find first entity matching filter
   * @returns First matching entity or null
   */
  findFirst(filter: Filter<T>): Promise<T | null>;

  /**
   * Find multiple entities with filtering, sorting, pagination
   */
  findMany(options?: QueryOptions<T>): Promise<QueryResult<T>>;

  /**
   * Count entities matching filter
   */
  count(filter?: Filter<T>): Promise<number>;

  /**
   * Check if entity exists by ID
   */
  exists(id: string): Promise<boolean>;

  /**
   * Find multiple entities by IDs (batch lookup)
   * FIX H1: Added for efficient batch ID lookups
   * @returns Array of found entities (missing IDs return null in same position)
   */
  findByMany(ids: string[]): Promise<(T | null)[]>;
}

// ============================================================================
// Write Repository Interface (Mutation operations)
// ============================================================================

/**
 * Protected fields that cannot be updated through update()
 * FIX H2: Prevent accidental modification of system-managed fields
 */
type ProtectedFields = 'id' | 'type' | 'createdAt';

/**
 * Update input type - excludes protected fields
 */
export type UpdateInput<T extends Entity> = Omit<Partial<T>, ProtectedFields>;

export interface WriteRepository<T extends Entity> {
  /**
   * Create a new entity
   * @returns Created entity with generated fields
   */
  create(data: CreateInput<T>): Promise<T>;

  /**
   * Update existing entity
   * FIX H2: Uses UpdateInput to prevent modification of protected fields
   * FIX M1: Optional expectedVersion for optimistic concurrency control
   * @param expectedVersion - If provided, throws ConcurrentModificationError if version mismatch
   * @returns Updated entity
   * @throws EntityNotFoundError if entity doesn't exist
   * @throws ConcurrentModificationError if version mismatch (optimistic locking)
   */
  update(id: string, updates: UpdateInput<T>, expectedVersion?: number): Promise<T>;

  /**
   * Delete entity by ID
   * @returns true if deleted, false if not found
   */
  delete(id: string): Promise<boolean>;
}

// ============================================================================
// Bulk Repository Interface (Batch operations)
// ============================================================================

export interface BulkRepository<T extends Entity> {
  /**
   * Create multiple entities
   * @returns Array of created entities
   */
  createMany(data: CreateInput<T>[]): Promise<T[]>;

  /**
   * Update multiple entities matching filter
   * FIX H2: Uses UpdateInput to prevent modification of protected fields
   * @returns Number of updated entities
   */
  updateMany(filter: Filter<T>, updates: UpdateInput<T>): Promise<number>;

  /**
   * Delete multiple entities matching filter
   * @returns Number of deleted entities
   */
  deleteMany(filter: Filter<T>): Promise<number>;
}

// ============================================================================
// Full Repository Interface (combines all)
// ============================================================================

export interface Repository<T extends Entity>
  extends ReadRepository<T>,
    WriteRepository<T>,
    BulkRepository<T> {}

// ============================================================================
// Link Repository Interface (Link doesn't extend Entity)
// ============================================================================

/**
 * Filter interface for Link queries
 * FIX M2: Added for deleteMany operations
 */
export interface LinkFilter {
  sourceId?: string;
  targetId?: string;
  relationType?: RelationType;
}

/**
 * Specialized repository for Link entities
 * Link has different structure (no 'type', 'metadata', 'updatedAt', 'version')
 */
export interface LinkRepository {
  create(data: Omit<Link, 'id' | 'createdAt'>): Promise<Link>;
  findById(id: string): Promise<Link | null>;
  // FIX H3: Type-safe relationType parameter (uses RelationType enum from types.ts)
  findBySource(sourceId: string, relationType?: RelationType): Promise<Link[]>;
  findByTarget(targetId: string, relationType?: RelationType): Promise<Link[]>;
  findByEntity(entityId: string, direction?: 'incoming' | 'outgoing' | 'both'): Promise<Link[]>;
  delete(id: string): Promise<boolean>;
  deleteByEntity(entityId: string): Promise<number>;

  // FIX M2: Bulk operations for Link entities
  createMany(links: Omit<Link, 'id' | 'createdAt'>[]): Promise<Link[]>;
  deleteMany(filter: LinkFilter): Promise<number>;
}

// ============================================================================
// Unit of Work Interface (Transaction support)
// ============================================================================

/**
 * Transaction isolation levels (for SQL backends)
 * FIX M3: Future SQL implementations can use proper isolation levels
 */
export type IsolationLevel =
  | 'READ_UNCOMMITTED'
  | 'READ_COMMITTED'
  | 'REPEATABLE_READ'
  | 'SERIALIZABLE';

export interface UnitOfWork {
  // Entity repositories
  requirements: Repository<Requirement>;
  solutions: Repository<Solution>;
  decisions: Repository<Decision>;
  phases: Repository<Phase>;
  artifacts: Repository<Artifact>;

  // Link repository (specialized)
  links: LinkRepository;

  // Transaction control
  // FIX M3: Optional isolation level for SQL backends (ignored by file storage)
  beginTransaction(isolationLevel?: IsolationLevel): Promise<void>;
  commit(): Promise<void>;
  rollback(): Promise<void>;

  // Transaction state
  isTransactionActive(): boolean;
}

// ============================================================================
// Repository Provider Interface (for Dependency Injection)
// ============================================================================

export interface RepositoryProvider {
  createUnitOfWork(planId: string): UnitOfWork;
}
```

---

## 2. Error Handling Strategy

### 2.1 Error Types

```typescript
// src/domain/repositories/errors.ts

/**
 * Error codes for repository operations
 */
export enum StorageErrorCode {
  // Entity errors
  ENTITY_NOT_FOUND = 'ENTITY_NOT_FOUND',
  ENTITY_CORRUPTED = 'ENTITY_CORRUPTED',
  ENTITY_ALREADY_EXISTS = 'ENTITY_ALREADY_EXISTS',

  // Index errors
  INDEX_OUT_OF_SYNC = 'INDEX_OUT_OF_SYNC',
  INDEX_CORRUPTED = 'INDEX_CORRUPTED',

  // Concurrency errors
  CONCURRENT_MODIFICATION = 'CONCURRENT_MODIFICATION',
  LOCK_TIMEOUT = 'LOCK_TIMEOUT',

  // Transaction errors
  TRANSACTION_FAILED = 'TRANSACTION_FAILED',
  NO_TRANSACTION_ACTIVE = 'NO_TRANSACTION_ACTIVE',

  // Storage errors
  STORAGE_UNAVAILABLE = 'STORAGE_UNAVAILABLE',
  DISK_FULL = 'DISK_FULL',
  PERMISSION_DENIED = 'PERMISSION_DENIED',
}

/**
 * Base error class for repository operations
 */
export class StorageError extends Error {
  constructor(
    public code: StorageErrorCode,
    message: string,
    public details?: unknown
  ) {
    super(message);
    this.name = 'StorageError';
  }
}

/**
 * Entity not found error
 */
export class EntityNotFoundError extends StorageError {
  constructor(entityType: string, id: string) {
    super(
      StorageErrorCode.ENTITY_NOT_FOUND,
      `${entityType} with id ${id} not found`
    );
    this.name = 'EntityNotFoundError';
  }
}

/**
 * Concurrent modification error (optimistic locking)
 */
export class ConcurrentModificationError extends StorageError {
  constructor(entityId: string, expectedVersion: number, actualVersion: number) {
    super(
      StorageErrorCode.CONCURRENT_MODIFICATION,
      `Entity ${entityId} was modified concurrently. Expected version ${expectedVersion}, got ${actualVersion}`,
      { entityId, expectedVersion, actualVersion }
    );
    this.name = 'ConcurrentModificationError';
  }
}
```

### 2.2 Error Recovery Strategies

```typescript
// src/infrastructure/repositories/file/error-recovery.ts

class ErrorRecovery {
  /**
   * Recover from corrupted entity file
   */
  async recoverCorruptedEntity<T extends Entity>(
    entityType: string,
    id: string
  ): Promise<T | null> {
    // 1. Try to load from version history
    const history = await this.loadHistory(entityType, id);
    if (history && history.versions.length > 0) {
      const lastValid = history.versions[history.versions.length - 1];
      return lastValid.data as T;
    }

    // 2. Remove from index to prevent future errors
    await this.indexManager.removeEntry(id);

    return null;
  }

  /**
   * Rebuild index from entity files
   */
  async rebuildIndex<T extends Entity>(
    planId: string,
    entityType: string
  ): Promise<void> {
    const entitiesDir = `.mcp-plans/plans/${planId}/entities/${entityType}`;
    const files = await fs.readdir(entitiesDir);

    const index: EntityIndex<T> = {
      version: 1,
      lastUpdated: new Date().toISOString(),
      count: 0,
      entries: {}
    };

    for (const file of files) {
      if (!file.endsWith('.json')) continue;

      try {
        const data = await fs.readFile(
          path.join(entitiesDir, file),
          'utf-8'
        );
        const entity = JSON.parse(data) as T;

        index.entries[entity.id] = this.extractIndexFields(entity);
        index.count++;
      } catch (error) {
        console.error(`Failed to read ${file}, skipping:`, error);
      }
    }

    await this.indexManager.save(index);
  }
}
```

---

## 3. File Storage Strategy

### 3.1 Directory Structure (Revised)

```
.mcp-plans/
├── config.json                          # Storage configuration
├── plans/
│   └── {planId}/
│       ├── manifest.json                # Plan metadata
│       ├── index/
│       │   ├── requirements.idx.json    # Index: {id → lightweight metadata}
│       │   ├── solutions.idx.json
│       │   ├── phases.idx.json
│       │   ├── decisions.idx.json
│       │   ├── artifacts.idx.json
│       │   └── links.idx.json           # Links also get an index
│       ├── entities/
│       │   ├── requirements/
│       │   │   ├── {reqId-1}.json       # One file per entity
│       │   │   ├── {reqId-2}.json
│       │   │   └── ...
│       │   ├── solutions/
│       │   ├── phases/
│       │   ├── decisions/
│       │   └── artifacts/
│       ├── links/
│       │   └── {linkId}.json            # One file per link
│       └── history/                     # Already implemented correctly
│           └── {entityType}/{entityId}.json
```

### 3.2 Index Structure

```typescript
// src/infrastructure/repositories/file/types.ts

/**
 * Base index file structure (generic, works for any indexed data)
 * FIX #1: Removed T extends Entity constraint for Link compatibility
 */
export interface BaseIndex<TMetadata> {
  indexVersion: number;      // FIX #27: Renamed from 'version' to avoid confusion with entity version
  lastUpdated: string;       // ISO timestamp
  count: number;             // Total entities
  entries: {
    [id: string]: TMetadata;
  };
}

/**
 * Entity index (for types extending Entity)
 */
export type EntityIndex<T extends Entity> = BaseIndex<IndexMetadata>;

/**
 * Link index (for Link type which doesn't extend Entity)
 * FIX #2: Separate type for Link compatibility
 */
export type LinkIndex = BaseIndex<LinkIndexMetadata>;

/**
 * Lightweight metadata stored in index for Entity types
 * Only fields needed for filtering/sorting
 * FIX H4, H5: Extended with additional queryable fields
 */
export interface IndexMetadata {
  // Common fields (all entities)
  title: string;
  status: string;
  createdAt: string;
  updatedAt: string;
  version: number;

  // Optional fields (entity-specific)
  priority?: string;
  category?: string;

  // FIX H6: Requirement votes for prioritization queries
  votes?: number;

  // FIX H7: Artifact type for filtering
  artifactType?: string;

  // FIX C4: Phase hierarchy fields for parent/child queries
  parentId?: string | null;
  order?: number;
  depth?: number;
  progress?: number;
  path?: string;

  // FIX H4: Phase blocking reason for quick status queries
  blockingReason?: string;

  // FIX H5: Additional queryable fields
  slug?: string;              // Artifact slug
  rationale?: string;         // Requirement rationale (truncated)
  approach?: string;          // Solution approach (truncated)
  selectionReason?: string;   // Solution selection reason
  impactScope?: string[];     // Decision impact scope
  supersedes?: string;        // Decision supersedes ID
  supersededBy?: string;      // Decision superseded by ID

  // For quick relationship queries
  // Maps: Solution.addressing[], Artifact.relatedRequirementIds[], relatedPhaseId, relatedSolutionId
  relatedIds?: string[];

  // FIX CR-C2: Schedule fields for date-based queries (flattened from Phase.schedule)
  estimatedEffortValue?: number;    // Phase.schedule.estimatedEffort.value
  estimatedEffortUnit?: string;     // Phase.schedule.estimatedEffort.unit
  dueDate?: string;                 // Phase.schedule.dueDate (ISO 8601)
}

/**
 * Lightweight metadata for Link index
 * FIX #2: Separate interface for Link type
 */
export interface LinkIndexMetadata {
  sourceId: string;
  targetId: string;
  relationType: RelationType;  // FIX C2: Type-safe relation type (not string)
  createdAt: string;
}
```

> **LIMITATION: Nested Field Filtering**
>
> IndexMetadata only stores **top-level and flattened fields**. You CANNOT filter by:
> - `metadata.createdBy` (use application-level filtering after load)
> - `evaluation.technicalFeasibility` (not indexed)
> - `source.type` (not indexed)
> - `schedule.startDate` (only `dueDate` and `estimatedEffort` are flattened)
>
> For complex queries on nested fields, load entities with `findMany()` and filter in application code.
> Future SQL backends may support dot-notation queries (e.g., `metadata->>'createdBy'`).

### 3.3 IndexManager Implementation (COMPLETE)

```typescript
// src/infrastructure/repositories/file/index-manager.ts

import * as fs from 'fs/promises';
import * as util from 'util';
import * as path from 'path';
import * as crypto from 'crypto';  // FIX C4: Use crypto for collision-free temp files
import gracefulFs from 'graceful-fs';
import lockfile from 'proper-lockfile';
import { Entity } from '../../../domain/entities/types.js';
import { EntityIndex, IndexMetadata, BaseIndex } from './types.js';

// graceful-fs provides retry logic for Windows file locking issues (EPERM/EBUSY/EACCES)
const gracefulRename = util.promisify(gracefulFs.rename);

const INDEX_CACHE_TTL = 5000; // 5 seconds

/**
 * Generic IndexManager that works with any metadata type
 * FIX #1: Made generic over TMetadata instead of T extends Entity
 */
export class IndexManager<TMetadata> {
  private indexPath: string;
  private lockPath: string;
  private index: BaseIndex<TMetadata> | null = null;
  private lastLoadTime: number = 0;
  private loadPromise: Promise<BaseIndex<TMetadata>> | null = null; // FIX #3: Load deduplication

  constructor(
    private planId: string,
    private entityType: string
  ) {
    this.indexPath = `.mcp-plans/plans/${planId}/index/${entityType}.idx.json`;
    this.lockPath = `${this.indexPath}.lock`;
  }

  /**
   * Load index from disk (with caching, TTL, and deduplication)
   * FIX #3: Deduplicate concurrent loads to prevent race condition
   */
  async load(forceReload = false): Promise<BaseIndex<TMetadata>> {
    const now = Date.now();

    // Return cached if valid
    if (this.index && !forceReload && (now - this.lastLoadTime) <= INDEX_CACHE_TTL) {
      return this.index;
    }

    // FIX #3: Deduplicate concurrent loads
    if (this.loadPromise && !forceReload) {
      return this.loadPromise;
    }

    this.loadPromise = this.loadFromDisk();

    try {
      this.index = await this.loadPromise;
      this.lastLoadTime = Date.now();
      return this.index;
    } finally {
      this.loadPromise = null;
    }
  }

  /**
   * Internal: Load index from disk
   */
  private async loadFromDisk(): Promise<BaseIndex<TMetadata>> {
    try {
      const data = await fs.readFile(this.indexPath, 'utf-8');
      return JSON.parse(data);
    } catch (error: any) {
      if (error.code === 'ENOENT') {
        // Index doesn't exist - create empty one
        return {
          indexVersion: 1, // FIX #27: Renamed from 'version'
          lastUpdated: new Date().toISOString(),
          count: 0,
          entries: {}
        };
      }
      throw error;
    }
  }

  /**
   * Add entry to index (in-memory only)
   * FIX #19: Only increment count if entry is new
   */
  async addEntry(id: string, metadata: TMetadata): Promise<void> {
    const index = await this.load();
    const isNew = !(id in index.entries); // FIX #19: Check if new
    index.entries[id] = metadata;
    if (isNew) {
      index.count++; // FIX #19: Only increment for new entries
    }
    index.lastUpdated = new Date().toISOString();
    index.indexVersion++;
  }

  /**
   * Update entry in index (in-memory only)
   */
  async updateEntry(id: string, metadata: TMetadata): Promise<void> {
    const index = await this.load();
    if (!(id in index.entries)) {
      throw new Error(`Entry ${id} not found in index`);
    }
    index.entries[id] = metadata;
    index.lastUpdated = new Date().toISOString();
    index.indexVersion++;
  }

  /**
   * Remove entry from index (in-memory only)
   */
  async removeEntry(id: string): Promise<void> {
    const index = await this.load();
    if (id in index.entries) {
      delete index.entries[id];
      index.count--;
      index.lastUpdated = new Date().toISOString();
      index.indexVersion++;
    }
  }

  /**
   * Invalidate cache to force reload on next access
   * FIX #4: Prevent memory leak by allowing cache invalidation
   * FIX H6: Clear reference to prevent memory leak on large indexes
   */
  invalidateCache(): void {
    this.lastLoadTime = 0;
    this.index = null;  // FIX H6: Clear reference to allow GC
  }

  /**
   * Flush in-memory index to disk
   */
  async flush(): Promise<void> {
    if (!this.index) return;

    // Ensure directory exists
    await fs.mkdir(path.dirname(this.indexPath), { recursive: true });

    // Write atomically
    await this.atomicWrite(this.indexPath, this.index);
  }

  /**
   * Execute operation with exclusive lock
   * NOTE: proper-lockfile is NOT reentrant - see LockManager for reentrant locks
   */
  async withLock<R>(fn: () => Promise<R>): Promise<R> {
    // Ensure lock file parent directory exists
    await fs.mkdir(path.dirname(this.lockPath), { recursive: true });

    // Create lock file if it doesn't exist
    try {
      await fs.writeFile(this.lockPath, '', { flag: 'wx' });
    } catch {
      // File already exists, that's fine
    }

    const release = await lockfile.lock(this.lockPath, {
      retries: {
        retries: 10,
        minTimeout: 100,
        maxTimeout: 1000
      },
      realpath: false // REQUIRED for Windows compatibility (FIX #16)
    });

    try {
      return await fn();
    } finally {
      await release();
    }
  }

  /**
   * Atomic write using temp file + rename
   * FIX C4: Use crypto.randomBytes for collision-free temp file names
   */
  private async atomicWrite(filePath: string, data: unknown): Promise<void> {
    // FIX C4: Use crypto.randomBytes(8) = 16 hex chars = 2^64 combinations (virtually collision-free)
    const tmpPath = `${filePath}.tmp.${Date.now()}.${crypto.randomBytes(8).toString('hex')}`;

    try {
      await fs.writeFile(tmpPath, JSON.stringify(data, null, 2), 'utf-8');

      // Verify JSON is valid
      const written = await fs.readFile(tmpPath, 'utf-8');
      JSON.parse(written);

      // Atomic rename using graceful-fs (Windows compatibility)
      await gracefulRename(tmpPath, filePath);
    } catch (error) {
      // Cleanup temp file on error
      await fs.unlink(tmpPath).catch(() => {});
      throw error;
    }
  }

  /**
   * Save index to disk (convenience method)
   */
  async save(index: BaseIndex<TMetadata>): Promise<void> {
    this.index = index;
    this.lastLoadTime = Date.now();
    await this.flush();
  }
}

/**
 * Factory function for creating typed IndexManagers
 */
export function createEntityIndexManager<T extends Entity>(
  planId: string,
  entityType: string
): IndexManager<IndexMetadata> {
  return new IndexManager<IndexMetadata>(planId, entityType);
}

export function createLinkIndexManager(
  planId: string
): IndexManager<LinkIndexMetadata> {
  return new IndexManager<LinkIndexMetadata>(planId, 'links');
}
```

### 3.4 LockManager for Reentrant Locks (FIX #6)

```typescript
// src/infrastructure/repositories/file/lock-manager.ts

/**
 * Manages reentrant locks for file operations
 * FIX #6: proper-lockfile is NOT reentrant, this wrapper provides reentrancy
 */
export class LockManager {
  private activeLocks = new Map<string, { count: number; promise: Promise<void> }>();
  private lockReleases = new Map<string, () => Promise<void>>();

  /**
   * Acquire a reentrant lock
   * If the same key is locked multiple times, increments counter instead of blocking
   */
  async acquire<R>(key: string, indexManager: IndexManager<any>, fn: () => Promise<R>): Promise<R> {
    const existing = this.activeLocks.get(key);

    if (existing) {
      // Lock already held - increment count and execute immediately
      existing.count++;
      try {
        return await fn();
      } finally {
        existing.count--;
        if (existing.count === 0) {
          this.activeLocks.delete(key);
          const release = this.lockReleases.get(key);
          if (release) {
            await release();
            this.lockReleases.delete(key);
          }
        }
      }
    }

    // First acquisition - get actual lock
    return indexManager.withLock(async () => {
      this.activeLocks.set(key, { count: 1, promise: Promise.resolve() });
      try {
        return await fn();
      } finally {
        const lock = this.activeLocks.get(key);
        if (lock) {
          lock.count--;
          if (lock.count === 0) {
            this.activeLocks.delete(key);
          }
        }
      }
    });
  }
}
```

---

## 4. FileRepository Implementation (COMPLETE)

### 4.1 Full Implementation with All Methods

```typescript
// src/infrastructure/repositories/file/file-repository.ts

import * as fs from 'fs/promises';
import * as util from 'util';
import * as path from 'path';
import * as crypto from 'crypto';  // FIX C4: Use crypto for collision-free temp files
import gracefulFs from 'graceful-fs';
import { LRUCache } from 'lru-cache';
import { v4 as uuidv4 } from 'uuid';
import {
  Entity,
  EntityType,
  Tag
} from '../../../domain/entities/types.js';
import {
  Repository,
  CreateInput,
  QueryOptions,
  QueryResult,
  Filter,
  FilterOperators
} from '../../../domain/repositories/interfaces.js';
import {
  EntityNotFoundError,
  ConcurrentModificationError,  // FIX M1: Import for optimistic locking
  StorageError,
  StorageErrorCode
} from '../../../domain/repositories/errors.js';
import { IndexManager } from './index-manager.js';
import { IndexMetadata } from './types.js';

// graceful-fs provides retry logic for Windows file locking issues (EPERM/EBUSY/EACCES)
const gracefulRename = util.promisify(gracefulFs.rename);

// Default cache sizes per entity type
const DEFAULT_CACHE_SIZES: Record<string, number> = {
  requirements: 100,
  solutions: 50,
  decisions: 50,
  phases: 500,      // Large tree structures
  artifacts: 10,    // Heavy sourceCode field - minimal cache
  links: 200
};

const BATCH_LOAD_SIZE = 50; // Load entities in batches to avoid file handle exhaustion

export class FileRepository<T extends Entity> implements Repository<T> {
  private basePath: string;
  private indexManager: IndexManager<IndexMetadata>; // FIX #1: Use IndexMetadata not T
  private cache: LRUCache<string, T>;

  constructor(
    private planId: string,
    private entityType: EntityType,
    options?: { cacheSize?: number; basePath?: string }
  ) {
    const baseDir = options?.basePath ?? '.mcp-plans';
    this.basePath = `${baseDir}/plans/${planId}/entities/${entityType}`;
    this.indexManager = new IndexManager<IndexMetadata>(planId, entityType); // FIX #1

    const cacheSize = options?.cacheSize ?? DEFAULT_CACHE_SIZES[entityType] ?? 100;
    this.cache = new LRUCache({ max: cacheSize });
  }

  // =========================================================================
  // CREATE Operations
  // =========================================================================

  async create(data: CreateInput<T>): Promise<T> {
    const id = uuidv4();
    const now = new Date().toISOString();

    // FIX CR-H6: Generate slug for Artifact entities if not provided
    const processedData = this.entityType === 'artifact' && !(data as any).slug
      ? { ...data, slug: this.generateSlug((data as any).title) }
      : data;

    const entity: T = {
      ...processedData,
      id,
      type: this.entityType,
      createdAt: now,
      updatedAt: now,
      version: 1,
      metadata: {
        createdBy: 'claude-code',  // FIX CR-H5: Auto-set createdBy
        tags: data.tags || [],
        annotations: []            // FIX CR-H5: Start with empty annotations
      }
    } as unknown as T;

    // Use lock to ensure atomic write to both file and index
    await this.indexManager.withLock(async () => {
      try {
        // 1. Write entity file
        await this.writeEntityFile(id, entity);

        // 2. Update index
        await this.indexManager.addEntry(id, this.extractIndexFields(entity));

        // 3. Flush index to disk
        await this.indexManager.flush();

      } catch (error) {
        // Rollback: delete entity file if index update failed
        await this.deleteEntityFile(id).catch(() => {});
        throw error;
      }
    });

    // 4. Update cache
    this.cache.set(id, entity);

    return entity;
  }

  /**
   * Create multiple entities in a single lock acquisition
   * FIX #15: Batch all operations under single lock to avoid 50x lock contention
   * FIX C3: Track written files and rollback on partial failure
   */
  async createMany(data: CreateInput<T>[]): Promise<T[]> {
    if (data.length === 0) return [];

    const entities: T[] = [];
    const now = new Date().toISOString();

    // Build all entities first
    for (const input of data) {
      const id = uuidv4();
      const entity: T = {
        ...input,
        id,
        type: this.entityType,
        createdAt: now,
        updatedAt: now,
        version: 1,
        metadata: {
          createdBy: 'claude-code',
          tags: input.tags || [],
          annotations: []
        }
      } as unknown as T;
      entities.push(entity);
    }

    // FIX C3: Track written IDs for rollback on partial failure
    const writtenIds: string[] = [];

    // Single lock for all operations (FIX #15)
    await this.indexManager.withLock(async () => {
      try {
        for (const entity of entities) {
          await this.writeEntityFile(entity.id, entity);
          writtenIds.push(entity.id);  // FIX C3: Track written
          await this.indexManager.addEntry(entity.id, this.extractIndexFields(entity));
        }
        await this.indexManager.flush(); // Single flush at the end
      } catch (error) {
        // FIX C3: ROLLBACK - Delete orphaned files on partial failure
        for (const id of writtenIds) {
          await this.deleteEntityFile(id).catch(() => {});
          await this.indexManager.removeEntry(id).catch(() => {});
        }
        throw error;  // Re-throw after cleanup
      }
    });

    // Update cache
    entities.forEach(e => this.cache.set(e.id, e));

    return entities;
  }

  // =========================================================================
  // READ Operations
  // =========================================================================

  async findById(id: string): Promise<T | null> {
    // Check cache first
    if (this.cache.has(id)) {
      return this.cache.get(id)!;
    }

    // Load from file
    const filePath = this.getEntityPath(id);

    try {
      const data = await fs.readFile(filePath, 'utf-8');
      const entity = JSON.parse(data) as T;

      // Update cache
      this.cache.set(id, entity);

      return entity;
    } catch (error: any) {
      if (error.code === 'ENOENT') {
        // Check if entity is in index but file missing (index out of sync)
        const index = await this.indexManager.load();
        if (id in index.entries) {
          throw new StorageError(
            StorageErrorCode.INDEX_OUT_OF_SYNC,
            `Entity ${id} found in index but file missing. Run rebuildIndex to fix.`,
            { entityId: id, entityType: this.entityType }
          );
        }
        return null;
      }

      if (error instanceof SyntaxError) {
        throw new StorageError(
          StorageErrorCode.ENTITY_CORRUPTED,
          `Entity ${id} file is corrupted (invalid JSON)`,
          { entityId: id, entityType: this.entityType, error: error.message }
        );
      }

      throw error;
    }
  }

  async findFirst(filter: Filter<T>): Promise<T | null> {
    const result = await this.findMany({
      filter,
      pagination: { limit: 1, offset: 0 }
    });
    return result.data[0] || null;
  }

  async findMany(options?: QueryOptions<T>): Promise<QueryResult<T>> {
    // 1. Load index for filtering/sorting
    const index = await this.indexManager.load();

    // 2. Filter using index (without loading full entities)
    let entries = Object.entries(index.entries);

    if (options?.filter) {
      entries = entries.filter(([_, meta]) =>
        this.matchesFilter(meta, options.filter!)
      );
    }

    // 3. Sort
    if (options?.sort && options.sort.length > 0) {
      entries = this.sortEntries(entries, options.sort);
    }

    const total = entries.length;

    // 4. Paginate
    if (options?.pagination) {
      const { offset, limit } = options.pagination;
      entries = entries.slice(offset, offset + limit);
    }

    // 5. Load full entities in batches (to avoid file handle exhaustion)
    const ids = entries.map(([id]) => id);
    const data: T[] = [];

    for (let i = 0; i < ids.length; i += BATCH_LOAD_SIZE) {
      const batch = ids.slice(i, i + BATCH_LOAD_SIZE);
      const results = await Promise.all(
        batch.map(id => this.findById(id))
      );
      data.push(...results.filter(Boolean) as T[]);
    }

    // 6. Apply projection if needed
    const result = options?.fields
      ? data.map(e => this.project(e, options.fields!))
      : data;

    return {
      data: result as T[],
      total,
      hasMore: options?.pagination
        ? (options.pagination.offset + result.length) < total
        : false
    };
  }

  async count(filter?: Filter<T>): Promise<number> {
    const index = await this.indexManager.load();

    if (!filter) {
      return index.count;
    }

    const entries = Object.values(index.entries).filter(meta =>
      this.matchesFilter(meta, filter)
    );

    return entries.length;
  }

  async exists(id: string): Promise<boolean> {
    // Check cache first
    if (this.cache.has(id)) {
      return true;
    }

    // Check index (faster than file system)
    const index = await this.indexManager.load();
    return id in index.entries;
  }

  /**
   * Find multiple entities by IDs (batch lookup)
   * FIX H1: Efficient batch ID lookup preserving order
   */
  async findByMany(ids: string[]): Promise<(T | null)[]> {
    // Load in batches to avoid file handle exhaustion
    const results: (T | null)[] = [];

    for (let i = 0; i < ids.length; i += BATCH_LOAD_SIZE) {
      const batch = ids.slice(i, i + BATCH_LOAD_SIZE);
      const batchResults = await Promise.all(
        batch.map(id => this.findById(id))
      );
      results.push(...batchResults);
    }

    return results;
  }

  // =========================================================================
  // UPDATE Operations
  // =========================================================================

  /**
   * FIX M1: Support optimistic concurrency control with expectedVersion
   * FIX M5: Version check moved INSIDE lock to prevent race condition
   */
  async update(id: string, updates: Partial<T>, expectedVersion?: number): Promise<T> {
    let updated: T;

    // FIX M5: All checks and modifications inside lock for atomicity
    await this.indexManager.withLock(async () => {
      // 1. Load existing entity (inside lock)
      const existing = await this.findById(id);
      if (!existing) {
        throw new EntityNotFoundError(this.entityType, id);
      }

      // 2. FIX M5: Optimistic concurrency check INSIDE lock
      if (expectedVersion !== undefined && existing.version !== expectedVersion) {
        throw new ConcurrentModificationError(id, expectedVersion, existing.version);
      }

      // 3. Build updated entity
      updated = {
        ...existing,
        ...updates,
        // Prevent modification of protected fields
        id,
        type: existing.type,
        createdAt: existing.createdAt,
        updatedAt: new Date().toISOString(),
        version: existing.version + 1,
      };

      // 4. Write entity file
      await this.writeEntityFile(id, updated);

      // 5. Update index
      await this.indexManager.updateEntry(id, this.extractIndexFields(updated));

      // 6. Flush index
      await this.indexManager.flush();

      // 7. Update cache (inside lock - FIX M5)
      this.cache.set(id, updated);
    });

    return updated!;
  }

  async updateMany(filter: Filter<T>, updates: Partial<T>): Promise<number> {
    const result = await this.findMany({ filter });
    const ids = result.data.map(e => e.id);

    // Update in parallel batches
    let updatedCount = 0;

    for (let i = 0; i < ids.length; i += BATCH_LOAD_SIZE) {
      const batch = ids.slice(i, i + BATCH_LOAD_SIZE);
      await Promise.all(
        batch.map(async id => {
          await this.update(id, updates);
          updatedCount++;
        })
      );
    }

    return updatedCount;
  }

  // =========================================================================
  // DELETE Operations
  // =========================================================================

  async delete(id: string): Promise<boolean> {
    try {
      // FIX C2: All cache operations moved INSIDE lock to prevent race condition
      await this.indexManager.withLock(async () => {
        // 1. Delete entity file
        await this.deleteEntityFile(id);

        // 2. Remove from index
        await this.indexManager.removeEntry(id);

        // 3. Flush index
        await this.indexManager.flush();

        // 4. Remove from cache (INSIDE lock - FIX C2)
        this.cache.delete(id);

        // 5. Invalidate index cache (INSIDE lock - FIX C2)
        this.indexManager.invalidateCache();
      });

      return true;
    } catch (error: any) {
      if (error.code === 'ENOENT') {
        return false;
      }
      throw error;
    }
  }

  async deleteMany(filter: Filter<T>): Promise<number> {
    const result = await this.findMany({ filter });
    const ids = result.data.map(e => e.id);

    let deletedCount = 0;

    for (const id of ids) {
      if (await this.delete(id)) {
        deletedCount++;
      }
    }

    return deletedCount;
  }

  // =========================================================================
  // Private Helper Methods
  // =========================================================================

  private getEntityPath(id: string): string {
    return path.join(this.basePath, `${id}.json`);
  }

  private async writeEntityFile(id: string, entity: T): Promise<void> {
    // Ensure directory exists
    await fs.mkdir(this.basePath, { recursive: true });

    const filePath = this.getEntityPath(id);
    // FIX C4: Use crypto.randomBytes(8) = 16 hex chars = 2^64 combinations (virtually collision-free)
    const tmpPath = `${filePath}.tmp.${Date.now()}.${crypto.randomBytes(8).toString('hex')}`;

    try {
      // Write to temp file
      await fs.writeFile(tmpPath, JSON.stringify(entity, null, 2), 'utf-8');

      // Verify JSON is valid
      const written = await fs.readFile(tmpPath, 'utf-8');
      JSON.parse(written);

      // Atomic rename using graceful-fs (Windows compatibility)
      await gracefulRename(tmpPath, filePath);
    } catch (error: any) {
      // Cleanup temp file on error
      await fs.unlink(tmpPath).catch(() => {});

      // FIX #20: Handle disk full error with specific error type
      if (error.code === 'ENOSPC') {
        throw new StorageError(
          StorageErrorCode.DISK_FULL,
          'Insufficient disk space to write entity',
          { entityId: id, entityType: this.entityType }
        );
      }

      throw error;
    }
  }

  private async deleteEntityFile(id: string): Promise<void> {
    await fs.unlink(this.getEntityPath(id));
  }

  /**
   * Extract lightweight metadata for index storage
   * FIX M4: Added validation warnings for missing required fields
   */
  private extractIndexFields(entity: T): IndexMetadata {
    const anyEntity = entity as any;

    // FIX M4: Log warnings for missing required fields (helps debugging)
    if (!anyEntity.title && this.entityType !== 'artifact') {
      console.warn(`[IndexManager] Entity ${entity.id} missing 'title' field`);
    }
    if (!anyEntity.status) {
      console.warn(`[IndexManager] Entity ${entity.id} missing 'status' field`);
    }

    return {
      title: anyEntity.title || '',
      status: anyEntity.status || '',
      createdAt: entity.createdAt,
      updatedAt: entity.updatedAt,
      version: entity.version,
      priority: anyEntity.priority,
      category: anyEntity.category,
      // FIX H6, H7: Additional queryable fields
      votes: anyEntity.votes,
      artifactType: anyEntity.artifactType,
      // FIX C4: Phase hierarchy fields
      parentId: anyEntity.parentId,
      order: anyEntity.order,
      depth: anyEntity.depth,
      progress: anyEntity.progress,
      path: anyEntity.path,
      // FIX H4, H5: Extended index fields
      blockingReason: anyEntity.blockingReason,
      slug: anyEntity.slug,
      // FIX CR-H3: LIMITATION - truncated to 200 chars for index storage
      // Full-text search on these fields requires loading full entities
      rationale: anyEntity.rationale?.substring(0, 200),
      approach: anyEntity.approach?.substring(0, 200),
      selectionReason: anyEntity.selectionReason,
      impactScope: anyEntity.impactScope,
      supersedes: anyEntity.supersedes,
      supersededBy: anyEntity.supersededBy,
      relatedIds: this.extractRelatedIds(entity)
    };
  }

  /**
   * Extract related entity IDs for index
   * FIX #33: Properly handle arrays with type checking
   */
  private extractRelatedIds(entity: T): string[] | undefined {
    const anyEntity = entity as any;
    const ids: string[] = [];

    // FIX #33: Check array type before spreading
    if (Array.isArray(anyEntity.addressing)) {
      ids.push(...anyEntity.addressing);
    }
    if (typeof anyEntity.relatedPhaseId === 'string') {
      ids.push(anyEntity.relatedPhaseId);
    }
    if (typeof anyEntity.relatedSolutionId === 'string') {
      ids.push(anyEntity.relatedSolutionId);
    }
    if (Array.isArray(anyEntity.relatedRequirementIds)) {
      ids.push(...anyEntity.relatedRequirementIds);
    }

    return ids.length > 0 ? ids : undefined;
  }

  private matchesFilter(metadata: IndexMetadata, filter: Filter<T>): boolean {
    for (const [key, value] of Object.entries(filter)) {
      const metaValue = (metadata as any)[key];

      // Handle operator-based filters
      if (typeof value === 'object' && value !== null && !Array.isArray(value)) {
        const operators = value as FilterOperators<any>;

        if (operators.$eq !== undefined && metaValue !== operators.$eq) return false;
        if (operators.$ne !== undefined && metaValue === operators.$ne) return false;
        if (operators.$in !== undefined && !operators.$in.includes(metaValue)) return false;
        if (operators.$nin !== undefined && operators.$nin.includes(metaValue)) return false;
        if (operators.$gt !== undefined && !(metaValue > operators.$gt)) return false;
        if (operators.$gte !== undefined && !(metaValue >= operators.$gte)) return false;
        if (operators.$lt !== undefined && !(metaValue < operators.$lt)) return false;
        if (operators.$lte !== undefined && !(metaValue <= operators.$lte)) return false;
        if (operators.$contains !== undefined && typeof metaValue === 'string') {
          if (!metaValue.includes(operators.$contains)) return false;
        }
      } else {
        // FIX H5: Array membership check for relatedIds
        // If metaValue is array and filter value is single string, check membership
        if (Array.isArray(metaValue) && typeof value === 'string') {
          if (!metaValue.includes(value)) return false;
        } else if (metaValue !== value) {
          // Simple equality filter
          return false;
        }
      }
    }

    return true;
  }

  private sortEntries(
    entries: [string, IndexMetadata][],
    sort: Array<{ field: keyof T; order: 'asc' | 'desc' }>
  ): [string, IndexMetadata][] {
    return entries.sort((a, b) => {
      for (const { field, order } of sort) {
        const aVal = (a[1] as any)[field as string];
        const bVal = (b[1] as any)[field as string];

        if (aVal === bVal) continue;

        const comparison = aVal > bVal ? 1 : -1;
        return order === 'asc' ? comparison : -comparison;
      }
      return 0;
    });
  }

  /**
   * Project entity to include only specified fields
   * FIX #10, #23: Use proper generic type for type safety
   */
  private project<K extends keyof T>(entity: T, fields: K[]): Pick<T, K> {
    const projected = {} as Pick<T, K>;
    for (const field of fields) {
      projected[field] = entity[field];
    }
    return projected;
  }

  /**
   * Generate URL-friendly slug from title
   * FIX CR-H6: Used for Artifact.slug auto-generation
   */
  private generateSlug(title: string): string {
    return title
      .toLowerCase()
      .replace(/[^a-z0-9]+/g, '-')  // Replace non-alphanumeric with dashes
      .replace(/^-+|-+$/g, '')       // Trim leading/trailing dashes
      .substring(0, 100);            // Max 100 chars per types.ts
  }
}
```

### 4.2 FileLinkRepository Implementation

```typescript
// src/infrastructure/repositories/file/file-link-repository.ts

import * as fs from 'fs/promises';
import * as path from 'path';
import { v4 as uuidv4 } from 'uuid';
import { Link, RelationType } from '../../../domain/entities/types.js';
import { LinkRepository } from '../../../domain/repositories/interfaces.js';
import { IndexManager, createLinkIndexManager } from './index-manager.js';
import { LinkIndexMetadata } from './types.js'; // FIX #2: Use shared type

/**
 * File-based Link repository
 * FIX #1, #2: Uses specialized LinkIndexMetadata instead of Entity-based index
 */
export class FileLinkRepository implements LinkRepository {
  private basePath: string;
  private indexManager: IndexManager<LinkIndexMetadata>; // FIX #2: Proper type

  constructor(
    private planId: string,
    options?: { basePath?: string }
  ) {
    const baseDir = options?.basePath ?? '.mcp-plans';
    this.basePath = `${baseDir}/plans/${planId}/links`;
    this.indexManager = createLinkIndexManager(planId); // FIX #2: Use factory
  }

  async create(data: Omit<Link, 'id' | 'createdAt'>): Promise<Link> {
    const id = uuidv4();
    const now = new Date().toISOString();

    const link: Link = {
      ...data,
      id,
      createdAt: now
    };

    await this.indexManager.withLock(async () => {
      // Ensure directory exists
      await fs.mkdir(this.basePath, { recursive: true });

      // Write link file
      const filePath = path.join(this.basePath, `${id}.json`);
      await fs.writeFile(filePath, JSON.stringify(link, null, 2), 'utf-8');

      // FIX #2: Update index with proper LinkIndexMetadata
      await this.indexManager.addEntry(id, {
        sourceId: data.sourceId,
        targetId: data.targetId,
        relationType: data.relationType,
        createdAt: now
      });

      await this.indexManager.flush();
    });

    return link;
  }

  async findById(id: string): Promise<Link | null> {
    try {
      const filePath = path.join(this.basePath, `${id}.json`);
      const data = await fs.readFile(filePath, 'utf-8');
      return JSON.parse(data) as Link;
    } catch (error: any) {
      if (error.code === 'ENOENT') return null;
      throw error;
    }
  }

  // FIX C3: Match interface signature - RelationType not string
  async findBySource(sourceId: string, relationType?: RelationType): Promise<Link[]> {
    const index = await this.indexManager.load();
    const matchingIds = Object.entries(index.entries)
      .filter(([_, meta]) => {
        if (meta.sourceId !== sourceId) return false;
        if (relationType && meta.relationType !== relationType) return false;
        return true;
      })
      .map(([id]) => id);

    return Promise.all(matchingIds.map(id => this.findById(id)))
      .then(results => results.filter(Boolean) as Link[]);
  }

  // FIX C3: Match interface signature - RelationType not string
  async findByTarget(targetId: string, relationType?: RelationType): Promise<Link[]> {
    const index = await this.indexManager.load();
    const matchingIds = Object.entries(index.entries)
      .filter(([_, meta]) => {
        if (meta.targetId !== targetId) return false;
        if (relationType && meta.relationType !== relationType) return false;
        return true;
      })
      .map(([id]) => id);

    return Promise.all(matchingIds.map(id => this.findById(id)))
      .then(results => results.filter(Boolean) as Link[]);
  }

  async findByEntity(
    entityId: string,
    direction: 'incoming' | 'outgoing' | 'both' = 'both'
  ): Promise<Link[]> {
    const index = await this.indexManager.load();
    const matchingIds = Object.entries(index.entries)
      .filter(([_, meta]) => {
        const m = meta as any;
        if (direction === 'outgoing') return m.sourceId === entityId;
        if (direction === 'incoming') return m.targetId === entityId;
        return m.sourceId === entityId || m.targetId === entityId;
      })
      .map(([id]) => id);

    return Promise.all(matchingIds.map(id => this.findById(id)))
      .then(results => results.filter(Boolean) as Link[]);
  }

  async delete(id: string): Promise<boolean> {
    try {
      await this.indexManager.withLock(async () => {
        const filePath = path.join(this.basePath, `${id}.json`);
        await fs.unlink(filePath);
        await this.indexManager.removeEntry(id);
        await this.indexManager.flush();
      });
      return true;
    } catch (error: any) {
      if (error.code === 'ENOENT') return false;
      throw error;
    }
  }

  async deleteByEntity(entityId: string): Promise<number> {
    const links = await this.findByEntity(entityId, 'both');
    let deleted = 0;

    for (const link of links) {
      if (await this.delete(link.id)) {
        deleted++;
      }
    }

    return deleted;
  }

  /**
   * Create multiple links in a single lock acquisition
   * FIX M2: Bulk create for Link entities with rollback on partial failure
   */
  async createMany(data: Omit<Link, 'id' | 'createdAt'>[]): Promise<Link[]> {
    if (data.length === 0) return [];

    const links: Link[] = [];
    const now = new Date().toISOString();

    // Build all link objects first
    for (const input of data) {
      const id = uuidv4();
      links.push({ ...input, id, createdAt: now });
    }

    // Track written files for rollback
    const writtenIds: string[] = [];

    // Single lock for all operations
    await this.indexManager.withLock(async () => {
      try {
        await fs.mkdir(this.basePath, { recursive: true });

        for (const link of links) {
          const filePath = path.join(this.basePath, `${link.id}.json`);
          await fs.writeFile(filePath, JSON.stringify(link, null, 2), 'utf-8');
          writtenIds.push(link.id);

          // Update index with LinkIndexMetadata
          await this.indexManager.addEntry(link.id, {
            sourceId: link.sourceId,
            targetId: link.targetId,
            relationType: link.relationType,
            createdAt: link.createdAt
          });
        }

        await this.indexManager.flush();
      } catch (error) {
        // Rollback on partial failure - delete orphaned files
        for (const id of writtenIds) {
          await fs.unlink(path.join(this.basePath, `${id}.json`)).catch(() => {});
          await this.indexManager.removeEntry(id).catch(() => {});
        }
        throw error;
      }
    });

    return links;
  }

  /**
   * Delete multiple links matching filter
   * FIX M2: Bulk delete for Link entities
   */
  async deleteMany(filter: LinkFilter): Promise<number> {
    const index = await this.indexManager.load();

    // Find matching links by filter
    const matchingIds = Object.entries(index.entries)
      .filter(([_, meta]) => {
        if (filter.sourceId && meta.sourceId !== filter.sourceId) return false;
        if (filter.targetId && meta.targetId !== filter.targetId) return false;
        if (filter.relationType && meta.relationType !== filter.relationType) return false;
        return true;
      })
      .map(([id]) => id);

    let deleted = 0;
    for (const id of matchingIds) {
      if (await this.delete(id)) deleted++;
    }

    return deleted;
  }
}
```

### 4.3 FileUnitOfWork Implementation

```typescript
// src/infrastructure/repositories/file/file-unit-of-work.ts

import {
  Requirement,
  Solution,
  Decision,
  Phase,
  Artifact
} from '../../../domain/entities/types.js';
import {
  UnitOfWork,
  Repository,
  LinkRepository
} from '../../../domain/repositories/interfaces.js';
import {
  StorageError,
  StorageErrorCode
} from '../../../domain/repositories/errors.js';
import { FileRepository } from './file-repository.js';
import { FileLinkRepository } from './file-link-repository.js';

/**
 * File-based Unit of Work implementation
 *
 * NOTE: File storage cannot provide true ACID transactions.
 * This implementation provides "best-effort" transaction semantics:
 * - beginTransaction(): Starts buffering mode
 * - commit(): Writes all changes (not truly atomic across files)
 * - rollback(): Discards buffered changes
 *
 * For true ACID compliance, use SQLite or PostgreSQL backend.
 *
 * > ⚠️ **IMPORTANT LIMITATION (FIX C5):**
 * > FileUnitOfWork provides interface compatibility only. Rollback does NOT undo
 * > file writes. For true ACID transactions, use SQLite or PostgreSQL backend.
 * > This is by design - file systems cannot provide atomic multi-file operations.
 */
export class FileUnitOfWork implements UnitOfWork {
  // Repositories
  requirements: Repository<Requirement>;
  solutions: Repository<Solution>;
  decisions: Repository<Decision>;
  phases: Repository<Phase>;
  artifacts: Repository<Artifact>;
  links: LinkRepository;

  // Transaction state
  private transactionActive = false;

  constructor(
    private planId: string,
    options?: { basePath?: string }
  ) {
    const opts = { basePath: options?.basePath };

    this.requirements = new FileRepository<Requirement>(planId, 'requirement', opts);
    this.solutions = new FileRepository<Solution>(planId, 'solution', opts);
    this.decisions = new FileRepository<Decision>(planId, 'decision', opts);
    this.phases = new FileRepository<Phase>(planId, 'phase', opts);
    this.artifacts = new FileRepository<Artifact>(planId, 'artifact', opts);
    this.links = new FileLinkRepository(planId, opts);
  }

  async beginTransaction(): Promise<void> {
    if (this.transactionActive) {
      throw new StorageError(
        StorageErrorCode.TRANSACTION_FAILED,
        'Transaction already active. Commit or rollback first.'
      );
    }
    this.transactionActive = true;
    // Note: File storage doesn't truly buffer - each write is immediate
    // This flag is mainly for interface compatibility
  }

  async commit(): Promise<void> {
    if (!this.transactionActive) {
      throw new StorageError(
        StorageErrorCode.NO_TRANSACTION_ACTIVE,
        'No transaction active. Call beginTransaction first.'
      );
    }
    // For file storage, writes are already committed
    // Just reset the flag
    this.transactionActive = false;
  }

  async rollback(): Promise<void> {
    if (!this.transactionActive) {
      throw new StorageError(
        StorageErrorCode.NO_TRANSACTION_ACTIVE,
        'No transaction active. Call beginTransaction first.'
      );
    }
    // WARNING: File storage cannot truly rollback!
    // Any writes made before rollback are permanent
    console.warn(
      'FileUnitOfWork.rollback(): File storage cannot rollback committed writes. ' +
      'Use SQLite/PostgreSQL for true transaction support.'
    );
    this.transactionActive = false;
  }

  isTransactionActive(): boolean {
    return this.transactionActive;
  }
}
```

### 4.4 Plan/PlanManifest Storage Note

> **IMPORTANT:** Plan and PlanManifest storage is intentionally kept **outside** the Repository pattern.

**Rationale:**

1. **Root Container**: Plan is the root container that holds all other entities, not a child entity that belongs to a collection.

2. **Aggregate Statistics**: PlanManifest contains statistics (`totalRequirements`, `totalSolutions`, etc.) that aggregate counts across all entity types. These are computed values, not stored entity fields.

3. **Current Implementation**: `FileStorage.saveManifest/loadManifest` directly handles Plan storage in `{planId}/manifest.json`. This approach is sufficient and remains unchanged.

4. **No Repository Benefits**: Plan doesn't benefit from Repository pattern features:
   - No batch operations needed (one plan per operation)
   - No complex filtering/sorting
   - No concurrent modification concerns (plan-level locking is different)

#### PlanManifest.lockVersion vs UnitOfWork (FIX CR-M1)

`PlanManifest.lockVersion` is separate from entity-level `version` fields:

| Field | Scope | Purpose |
|-------|-------|---------|
| `PlanManifest.lockVersion` | Plan-level | Optimistic lock for concurrent plan modifications |
| `Entity.version` | Entity-level | Track individual entity changes, used by Repository.update(expectedVersion) |
| `UnitOfWork.beginTransaction()` | Transaction scope | Group multiple entity operations |

**Concurrency model:**
- Check `lockVersion` in `PlanService` before plan-wide operations
- Check `Entity.version` via `expectedVersion` parameter in Repository.update()
- Use UnitOfWork transactions for multi-entity atomic operations (SQL only)

**Storage Location:**
```
.mcp-plans/plans/{planId}/manifest.json
```

**When migrating to SQL backends**, Plan storage will use a dedicated `plans` table with statistics columns, managed directly by `PlanService`, not through the generic Repository interface.

---

## 5. Future Storage Backends

### 5.1 Planned Implementations

The Repository Pattern is designed to support multiple storage backends:

| Backend | Status | Use Case |
|---------|--------|----------|
| **File** | Implemented | Default storage, simple deployments |
| SQLite | Planned (Sprint 10) | Single-file database, medium-sized plans |
| PostgreSQL | Planned | Multi-user production deployments |
| MongoDB | Considered | Document-centric workflows |

### 5.2 Implementation Guidelines

When implementing additional backends:

1. **Implement `UnitOfWork` interface** - Each backend must implement full transaction support
2. **Column mapping** - For SQL backends, use `COLUMN_MAP` for camelCase to snake_case:
   ```typescript
   const COLUMN_MAP: Record<string, string> = {
     createdAt: 'created_at',
     updatedAt: 'updated_at',
     parentId: 'parent_id',
     order: 'sort_order',  // SQL reserved keyword
   };
   ```
3. **JSON columns** - Store arrays/objects as JSON TEXT in relational databases

   **Complete JSON Column Reference:**

   | Entity | Fields Requiring JSON Column |
   |--------|------------------------------|
   | **All Entities** | `metadata` (contains `createdBy`, `tags[]`, `annotations[]`) |
   | **Requirement** | `source: { type, context?, parentId? }`, `impact?: { scope[], complexityEstimate, riskLevel }`, `acceptanceCriteria[]` |
   | **Solution** | `tradeoffs[]: { aspect, pros[], cons[], score? }`, `evaluation: { effortEstimate, technicalFeasibility, riskAssessment, dependencies?, performanceImpact? }`, `addressing[]` |
   | **Decision** | `alternativesConsidered[]: { option, reasoning, whyNotChosen? }`, `impactScope[]` |
   | **Phase** | `schedule: { estimatedEffort, actualEffort?, startDate?, endDate?, dueDate? }`, `milestones[]?: { id, title, completed, completedAt? }`, `blockers[]?: { description, reportedAt, resolvedAt? }`, `objectives[]`, `deliverables[]`, `successCriteria[]` |
   | **Artifact** | `content: { language?, sourceCode?, filename? }`, `targets[]?: { path, action, lineNumber?, lineEnd?, searchPattern?, description? }`, `fileTable[]?` **(DEPRECATED)**, `relatedRequirementIds[]`, `codeRefs[]` |
   | **Link** | `metadata?: Record<string, unknown>` (schema-less, validate at application layer) |

   > **Note on Optional Fields:**
   > - `Tradeoff.score?` - optional 1-10 score
   > - `AlternativeConsidered.whyNotChosen?` - only for rejected alternatives
   > - All `?` fields may be `null` or absent in JSON

4. **True ACID** - SQL backends should use database transactions (not file-based simulation)
5. **Batch operations** - Implement `createMany`, `updateMany`, `deleteMany` using transactions

### 5.3 Link Entity Note

`Link` does NOT extend `Entity`. It has standalone fields:
- `id`, `sourceId`, `targetId`, `relationType`, `metadata?`, `createdAt`, `createdBy`

This must be handled specially in any backend implementation (separate table/collection).

#### RelationType Values (Complete List)

```typescript
type RelationType =
  | 'implements'      // Solution → Requirement
  | 'addresses'       // Phase → Requirement
  | 'depends_on'      // Phase → Phase (with cycle detection)
  | 'blocks'          // Phase → Phase
  | 'alternative_to'  // Solution → Solution
  | 'supersedes'      // Decision → Decision
  | 'references'      // Any → ContextReference (future)
  | 'derived_from'    // Requirement → Requirement
  | 'has_artifact';   // Phase/Solution → Artifact
```

#### Link.metadata Validation Strategy (FIX CR-H4)

`Link.metadata` is `Record<string, unknown>` - a schema-less JSON object.

**Validation approach:**
1. **File storage**: Accept any JSON-serializable object
2. **SQL backends**: Store as JSON/JSONB column
3. **Application layer**: Define expected schemas per `relationType` if needed

```typescript
// Example: depends_on links may store dependency type
interface DependsOnMetadata {
  dependencyType?: 'hard' | 'soft';
  reason?: string;
}

// LinkingService should validate metadata structure:
if (relationType === 'depends_on' && metadata) {
  // Validate against DependsOnMetadata schema
}
```

> **WARNING:** Do not store sensitive data in Link.metadata. It is not encrypted and may be exposed in exports.

### 5.4 Entity Field Reference (FIX L1, L2)

Complete field mapping for all entity types (from `src/domain/entities/types.ts`):

| Entity | Fields |
|--------|--------|
| **Entity** (base) | `id`, `type`, `createdAt`, `updatedAt`, `version`, `metadata: { createdBy, tags, annotations }` |
| **Requirement** | + `title`, `description`, `rationale?`, `source: { type, context?, parentId? }`, `acceptanceCriteria[]`, `priority`, `category`, `status`, `votes`, `impact?` |
| **Solution** | + `title`, `description`, `approach`, `implementationNotes?`, `tradeoffs[]`, `addressing[]`, `evaluation: { effortEstimate, technicalFeasibility, riskAssessment, dependencies?, performanceImpact? }`, `status`, `selectionReason?` |
| **Decision** | + `title`, `question`, `context`, `decision`, `alternativesConsidered[]`, `consequences?`, `impactScope?`, `status`, `supersededBy?`, `supersedes?` |
| **Phase** | + `title`, `description`, `parentId`, `order`, `depth`, `path`, `objectives[]`, `deliverables[]`, `successCriteria[]`, `schedule`, `status`, `progress`, `startedAt?`, `completedAt?`, `milestones?`, `blockers?`, `implementationNotes?`, `priority?`, `blockingReason?` |
| **Artifact** | + `title`, `description`, `slug?`, `artifactType`, `status`, `content`, `targets?`, `fileTable?` (deprecated), `relatedPhaseId?`, `relatedSolutionId?`, `relatedRequirementIds?`, `codeRefs?` |
| **Link** | `id`, `sourceId`, `targetId`, `relationType`, `metadata?`, `createdAt`, `createdBy` (NOT extends Entity) |

#### Status Enum Values

| Entity | Status Field | Allowed Values |
|--------|--------------|----------------|
| **Requirement** | `status` | `'draft'` \| `'approved'` \| `'implemented'` \| `'deferred'` \| `'rejected'` |
| **Requirement** | `priority` | `'critical'` \| `'high'` \| `'medium'` \| `'low'` |
| **Requirement** | `category` | `'functional'` \| `'non-functional'` \| `'technical'` \| `'business'` |
| **Solution** | `status` | `'proposed'` \| `'evaluated'` \| `'selected'` \| `'rejected'` \| `'implemented'` |
| **Decision** | `status` | `'active'` \| `'superseded'` \| `'reversed'` |
| **Phase** | `status` | `'planned'` \| `'in_progress'` \| `'completed'` \| `'blocked'` \| `'skipped'` |
| **Phase** | `priority` | `'critical'` \| `'high'` \| `'medium'` \| `'low'` |
| **Artifact** | `status` | `'draft'` \| `'reviewed'` \| `'approved'` \| `'implemented'` \| `'outdated'` |
| **Artifact** | `artifactType` | `'code'` \| `'config'` \| `'migration'` \| `'documentation'` \| `'test'` \| `'script'` \| `'other'` |

#### Helper Types

```typescript
// Tag - key-value pair for categorization
interface Tag {
  key: string;
  value: string;
}

// Annotation - timestamped note
interface Annotation {
  id: string;
  text: string;
  author: string;
  createdAt: string;  // ISO 8601
}

// EffortEstimate - used by Phase.schedule and Solution.evaluation
interface EffortEstimate {
  value: number;
  unit: 'minutes' | 'hours' | 'days' | 'weeks' | 'story-points';
  confidence: 'low' | 'medium' | 'high';
}

// Tradeoff - Solution tradeoff analysis
interface Tradeoff {
  aspect: string;
  pros: string[];
  cons: string[];
  score?: number;  // 1-10, OPTIONAL
}

// Milestone - Phase progress tracking
interface Milestone {
  id: string;
  title: string;
  completed: boolean;
  completedAt?: string;  // ISO 8601
}

// Blocker - Phase impediment
interface Blocker {
  description: string;
  reportedAt: string;   // ISO 8601
  resolvedAt?: string;  // ISO 8601
}

// ArtifactTarget - file target with precision (replaces deprecated FileEntry)
interface ArtifactTarget {
  path: string;
  action: 'create' | 'modify' | 'delete';
  lineNumber?: number;      // 1-indexed, specific line
  lineEnd?: number;         // End line for range (requires lineNumber)
  searchPattern?: string;   // Regex (conflicts with lineNumber)
  description?: string;
}

// AlternativeConsidered - Decision alternative
interface AlternativeConsidered {
  option: string;
  reasoning: string;
  whyNotChosen?: string;  // OPTIONAL - only for rejected alternatives
}
```

### 5.5 Phase Hierarchy Query Methods (FIX M2)

Phase entities require specialized query methods for hierarchy traversal:

```typescript
// Future methods to add to Repository<Phase> or PhaseRepository
interface PhaseHierarchyMethods {
  findByParent(parentId: string | null): Promise<Phase[]>;  // Get direct children
  findRoots(): Promise<Phase[]>;                            // Get top-level phases (parentId = null)
  findAncestors(phaseId: string): Promise<Phase[]>;         // Get all parents up to root
  findDescendants(phaseId: string): Promise<Phase[]>;       // Get all children recursively
}
```

**Current workaround:** Use `findMany({ filter: { parentId: value } })` with IndexMetadata.

### 5.6 Reserved for Future Implementation

Detailed SQLite schema and implementation will be documented in Sprint 10.
Key considerations already identified:
- Use `sort_order` column for Phase hierarchy (SQL reserved keyword `ORDER`)
- Store complex fields (metadata, arrays) as JSON TEXT
- Create indexes on frequently queried fields (status, type, parentId)

### 5.7 Architectural Considerations (FIX CR-A1 to CR-A5)

#### SQL JSON Path Query Strategy (CR-A1)

PostgreSQL requires JSON path operators for nested field queries:

```sql
-- Query nested JSON fields in PostgreSQL
SELECT * FROM requirements
WHERE source->>'type' = 'user-request'
  AND (impact->>'riskLevel')::text = 'high';

-- Query array membership
SELECT * FROM solutions
WHERE addressing @> '["req-uuid-123"]'::jsonb;

-- Query nested evaluation
SELECT * FROM solutions
WHERE (evaluation->'effortEstimate'->>'value')::int > 10;
```

**Abstraction strategy:**
```typescript
// SqlRepository should translate Filter<T> to SQL JSON paths
const SQL_JSON_PATHS: Record<string, string> = {
  'source.type': "source->>'type'",
  'evaluation.technicalFeasibility': "evaluation->>'technicalFeasibility'",
  'impact.riskLevel': "impact->>'riskLevel'",
};
```

#### Recommended SQL Indexes (CR-A2)

```sql
-- PostgreSQL index recommendations for frequently queried fields

-- Entity base indexes (all tables)
CREATE INDEX idx_{entity}_status ON {entity}(status);
CREATE INDEX idx_{entity}_created_at ON {entity}(created_at);
CREATE INDEX idx_{entity}_updated_at ON {entity}(updated_at);

-- Phase-specific indexes
CREATE INDEX idx_phases_parent_id ON phases(parent_id);
CREATE INDEX idx_phases_path ON phases(path);
CREATE INDEX idx_phases_sort_order ON phases(sort_order);

-- JSON path indexes (PostgreSQL GIN)
CREATE INDEX idx_solutions_addressing ON solutions USING GIN (addressing);
CREATE INDEX idx_requirements_source_type ON requirements ((source->>'type'));
CREATE INDEX idx_phases_schedule_due_date ON phases ((schedule->>'dueDate'));

-- Link indexes
CREATE INDEX idx_links_source_id ON links(source_id);
CREATE INDEX idx_links_target_id ON links(target_id);
CREATE INDEX idx_links_relation_type ON links(relation_type);
CREATE INDEX idx_links_source_relation ON links(source_id, relation_type);
```

#### File Storage Scalability (CR-A4)

| Plan Size | Index File Size | Recommendation |
|-----------|-----------------|----------------|
| < 1,000 entities | < 500KB | Default behavior OK |
| 1,000 - 10,000 | 500KB - 5MB | Consider index caching with longer TTL |
| > 10,000 | > 5MB | Migrate to SQLite backend |

**Future optimization:** Implement sharded indexes by entity type prefix or partitioned by `createdAt` month.

#### Index Integrity (CR-A5)

File storage does not automatically detect index corruption. Recommended recovery strategy:

```typescript
// Add to FileRepository startup
async validateIndexIntegrity(): Promise<boolean> {
  const index = await this.indexManager.load();
  const entityCount = await this.countEntityFiles();

  if (index.count !== entityCount) {
    console.warn(`Index out of sync: ${index.count} vs ${entityCount} files`);
    await this.rebuildIndex();
    return false;
  }
  return true;
}
```

> **Recommendation:** Run `validateIndexIntegrity()` on plan load, and provide `rebuildIndex` CLI command for manual recovery.

---

## 6. Service Integration

### 6.1 Repository Factory

```typescript
// src/infrastructure/factory/repository-factory.ts

import { UnitOfWork, RepositoryProvider } from '../../domain/repositories/interfaces.js';
import { FileUnitOfWork } from '../repositories/file/file-unit-of-work.js';
// import { SqliteUnitOfWork } from '../repositories/sqlite/sqlite-unit-of-work.js';

export type StorageType = 'file' | 'sqlite' | 'postgres' | 'mongo';

export interface StorageConfig {
  type: StorageType;
  options: {
    basePath?: string;      // For file storage
    dbPath?: string;        // For SQLite
    connectionString?: string; // For PostgreSQL
    uri?: string;           // For MongoDB
    database?: string;      // For MongoDB
  };
}

export class RepositoryFactory implements RepositoryProvider {
  constructor(private config: StorageConfig) {}

  createUnitOfWork(planId: string): UnitOfWork {
    switch (this.config.type) {
      case 'file':
        return new FileUnitOfWork(planId, {
          basePath: this.config.options.basePath
        });

      case 'sqlite':
        // return new SqliteUnitOfWork(planId, this.config.options.dbPath);
        throw new Error('SQLite support not yet implemented');

      case 'postgres':
        throw new Error('PostgreSQL support not yet implemented');

      case 'mongo':
        throw new Error('MongoDB support not yet implemented');

      default:
        throw new Error(`Unknown storage type: ${this.config.type}`);
    }
  }
}
```

### 6.2 VersionHistoryService Design Decision (FIX CR-M2)

> **DESIGN DECISION:** `VersionHistoryService` is intentionally kept **outside** the Repository pattern.

**Rationale:**
- Version history is **append-only** (no updates/deletes to individual snapshots)
- Storage structure differs from entities: `{planId}/history/{entityType}/{entityId}.json`
- No need for filtering, sorting, or pagination at the history level
- Current `FileStorage.saveVersion/loadVersion` API is sufficient

**Integration points:**
- Services call `versionHistoryService.saveVersion()` after entity create/update
- Services call `versionHistoryService.deleteHistory()` on entity delete
- Future SQL backends can use a dedicated `entity_history` table

### 6.3 QueryOptions.fields Limitation (FIX CR-M3)

`QueryOptions.fields` only supports **top-level field projection**:

```typescript
// Works: top-level fields
const result = await repo.findMany({
  fields: ['id', 'title', 'status']  // OK
});

// Does NOT work: nested fields
const result = await repo.findMany({
  fields: ['evaluation.technicalFeasibility']  // NOT SUPPORTED
});
```

For nested field projection, load full entities and project in application code.

### 6.4 Phase blockers[] vs blockingReason (FIX CR-M4)

Phase has two related but distinct fields for blocking status:

| Field | Type | Indexed | Use Case |
|-------|------|---------|----------|
| `blockers[]` | `Blocker[]` | No | Full blocker history with timestamps |
| `blockingReason` | `string` | **Yes** | Quick status text for UI display |

**Usage pattern:**
```typescript
// Set blockingReason for quick queries
await phaseRepo.update(id, {
  status: 'blocked',
  blockingReason: 'Waiting for API design approval',
  blockers: [
    ...existingBlockers,
    { description: 'API design pending', reportedAt: new Date().toISOString() }
  ]
});

// Index queries use blockingReason
const blocked = await phaseRepo.findMany({
  filter: { status: 'blocked' }
});
// blocked items have blockingReason in IndexMetadata
```

### 6.5 Clean Service Migration (No Legacy FileStorage)

> **IMPORTANT:** Repository pattern fully replaces FileStorage. No backward compatibility
> layer needed - clean migration eliminates dual code paths and reduces complexity.

```typescript
// src/domain/services/requirement-service.ts (MIGRATED)

import { RepositoryFactory } from '../../infrastructure/factory/repository-factory.js';
import { Repository } from '../repositories/interfaces.js';
import { Requirement } from '../entities/types.js';
import { PlanService } from './plan-service.js';
import { VersionHistoryService } from './version-history-service.js';

export class RequirementService {
  constructor(
    private repositoryFactory: RepositoryFactory,
    private planService: PlanService,
    private versionHistoryService?: VersionHistoryService
  ) {}

  /**
   * Get repository for plan via UnitOfWork
   */
  private getRepository(planId: string): Repository<Requirement> {
    return this.repositoryFactory.createUnitOfWork(planId).requirements;
  }

  async addRequirement(input: AddRequirementInput): Promise<AddRequirementResult> {
    const repo = this.getRepository(input.planId);

    const requirement = await repo.create({
      title: input.requirement.title,
      description: input.requirement.description,
      rationale: input.requirement.rationale,
      source: input.requirement.source,
      acceptanceCriteria: input.requirement.acceptanceCriteria || [],
      priority: input.requirement.priority || 'medium',
      category: input.requirement.category || 'functional',
      status: 'draft',
      votes: 0,
      impact: input.requirement.impact,
      tags: input.requirement.tags
    });

    // Save history if enabled
    if (this.versionHistoryService) {
      await this.versionHistoryService.saveVersion(
        input.planId,
        requirement.id,
        'requirement',
        requirement,
        1
      );
    }

    await this.planService.updateStatistics(input.planId);
    return { requirementId: requirement.id };
  }

  async listRequirements(input: ListRequirementsInput): Promise<ListRequirementsResult> {
    const repo = this.getRepository(input.planId);

    const result = await repo.findMany({
      filter: {
        ...(input.filters?.priority && { priority: input.filters.priority }),
        ...(input.filters?.status && { status: input.filters.status }),
        ...(input.filters?.category && { category: input.filters.category })
      },
      pagination: {
        limit: input.limit ?? 50,
        offset: input.offset ?? 0
      },
      sort: [{ field: 'createdAt', order: 'desc' }],
      fields: input.fields as any
    });

    return {
      requirements: result.data,
      total: result.total,
      hasMore: result.hasMore
    };
  }
}
```

> **⚠️ IMPORTANT: Version History Cleanup on Entity Deletion**
>
> When deleting entities through the Repository, you MUST also clean up associated version history
> to prevent orphan history files. Add cleanup logic to all `delete*` service methods:
>
> ```typescript
> async deleteRequirement(planId: string, id: string): Promise<void> {
>   const repo = this.getRepository(planId);
>   await repo.delete(id);
>
>   // IMPORTANT: Clean up associated version history to prevent orphan files
>   if (this.versionHistoryService) {
>     await this.versionHistoryService.deleteHistory(planId, id, 'requirement');
>   }
>
>   await this.planService.updateStatistics(planId);
> }
> ```
>
> **Why this matters:**
> - `VersionHistoryService` stores history in `{planId}/history/{entityType}/{entityId}.json`
> - Repository's `delete()` method only removes the entity file and index entry
> - History files are stored in a separate directory and must be cleaned up manually
> - Without cleanup, orphan history files will accumulate over time

### 6.3 Updated Service Initialization

```typescript
// src/server/services.ts (MIGRATED)

import { RepositoryFactory, StorageConfig } from '../infrastructure/factory/repository-factory.js';
import { PlanService } from '../domain/services/plan-service.js';
import { RequirementService } from '../domain/services/requirement-service.js';
import { VersionHistoryService } from '../domain/services/version-history-service.js';
// ... other imports

export interface ServicesConfig {
  storageConfig: StorageConfig;  // Required - no legacy fallback
}

export async function createServices(config: ServicesConfig): Promise<Services> {
  const repositoryFactory = new RepositoryFactory(config.storageConfig);

  // PlanService and VersionHistoryService also need migration to Repository pattern
  // For now they can use UnitOfWork directly
  const planService = new PlanService(repositoryFactory);
  const versionHistoryService = new VersionHistoryService(repositoryFactory);

  const requirementService = new RequirementService(
    repositoryFactory,
    planService,
    versionHistoryService
  );

  // ... create other services similarly

  return {
    repositoryFactory,
    planService,
    requirementService,
    // ...
  };
}

// Usage examples:

// File storage (default)
const services = await createServices({
  storageConfig: {
    type: 'file',
    options: { basePath: '.mcp-plans' }
  }
});

// SQLite (Sprint 10)
const servicesWithSqlite = await createServices({
  storageConfig: {
    type: 'sqlite',
    options: { dbPath: '.mcp-plans/plans.db' }
  }
});

// PostgreSQL (future)
const servicesWithPostgres = await createServices({
  storageConfig: {
    type: 'postgres',
    options: { connectionString: 'postgresql://localhost/mcp_planner' }
  }
});
```

---

## 7. Testing Strategy

### 7.1 Repository Tests

```typescript
// tests/infrastructure/repositories/file-repository.test.ts

import { describe, it, expect, beforeEach, afterEach } from 'vitest';
import * as fs from 'fs/promises';
import { FileRepository } from '../../../src/infrastructure/repositories/file/file-repository.js';
import { Requirement } from '../../../src/domain/entities/types.js';

describe('FileRepository', () => {
  const testPlanId = 'test-plan-' + Date.now();
  let repo: FileRepository<Requirement>;

  beforeEach(async () => {
    repo = new FileRepository<Requirement>(testPlanId, 'requirement');
  });

  afterEach(async () => {
    // Cleanup test data
    await fs.rm(`.mcp-plans/plans/${testPlanId}`, { recursive: true, force: true });
  });

  describe('CRUD Operations', () => {
    it('should create and retrieve entity', async () => {
      const created = await repo.create({
        title: 'Test Requirement',
        description: 'Test Description',
        source: { type: 'user-request' },
        acceptanceCriteria: ['Criterion 1'],
        priority: 'high',
        category: 'functional',
        status: 'draft',
        votes: 0
      });

      expect(created.id).toBeDefined();
      expect(created.title).toBe('Test Requirement');
      expect(created.version).toBe(1);

      const retrieved = await repo.findById(created.id);
      expect(retrieved).toEqual(created);
    });

    it('should update entity and increment version', async () => {
      const created = await repo.create({
        title: 'Original Title',
        description: 'Description',
        source: { type: 'user-request' },
        acceptanceCriteria: [],
        priority: 'medium',
        category: 'functional',
        status: 'draft',
        votes: 0
      });

      const updated = await repo.update(created.id, { title: 'Updated Title' });

      expect(updated.title).toBe('Updated Title');
      expect(updated.version).toBe(2);
      expect(updated.createdAt).toBe(created.createdAt);
      expect(updated.updatedAt).not.toBe(created.updatedAt);
    });

    it('should delete entity', async () => {
      const created = await repo.create({
        title: 'To Delete',
        description: 'Description',
        source: { type: 'user-request' },
        acceptanceCriteria: [],
        priority: 'low',
        category: 'functional',
        status: 'draft',
        votes: 0
      });

      const deleted = await repo.delete(created.id);
      expect(deleted).toBe(true);

      const retrieved = await repo.findById(created.id);
      expect(retrieved).toBeNull();
    });
  });

  describe('Query Operations', () => {
    beforeEach(async () => {
      // Create test data
      for (let i = 0; i < 10; i++) {
        await repo.create({
          title: `Requirement ${i}`,
          description: `Description ${i}`,
          source: { type: 'user-request' },
          acceptanceCriteria: [],
          priority: i % 2 === 0 ? 'high' : 'low',
          category: 'functional',
          status: 'draft',
          votes: i
        });
      }
    });

    it('should filter by priority', async () => {
      const result = await repo.findMany({
        filter: { priority: 'high' }
      });

      expect(result.data.length).toBe(5);
      expect(result.data.every(r => r.priority === 'high')).toBe(true);
    });

    it('should paginate results', async () => {
      const page1 = await repo.findMany({
        pagination: { limit: 3, offset: 0 }
      });

      expect(page1.data.length).toBe(3);
      expect(page1.total).toBe(10);
      expect(page1.hasMore).toBe(true);

      const page2 = await repo.findMany({
        pagination: { limit: 3, offset: 3 }
      });

      expect(page2.data.length).toBe(3);
      expect(page2.hasMore).toBe(true);

      // Ensure no overlap
      const ids1 = page1.data.map(r => r.id);
      const ids2 = page2.data.map(r => r.id);
      expect(ids1.some(id => ids2.includes(id))).toBe(false);
    });

    it('should sort results', async () => {
      const result = await repo.findMany({
        sort: [{ field: 'votes', order: 'desc' }]
      });

      for (let i = 1; i < result.data.length; i++) {
        expect(result.data[i - 1].votes).toBeGreaterThanOrEqual(result.data[i].votes);
      }
    });

    it('should count with filter', async () => {
      const highCount = await repo.count({ priority: 'high' });
      const lowCount = await repo.count({ priority: 'low' });

      expect(highCount).toBe(5);
      expect(lowCount).toBe(5);
    });
  });

  describe('Performance', () => {
    it('should create 1000 entities in reasonable time', async () => {
      const start = Date.now();

      const promises = [];
      for (let i = 0; i < 1000; i++) {
        promises.push(repo.create({
          title: `Requirement ${i}`,
          description: `Description ${i}`,
          source: { type: 'user-request' },
          acceptanceCriteria: [],
          priority: 'medium',
          category: 'functional',
          status: 'draft',
          votes: 0
        }));
      }

      await Promise.all(promises);

      const elapsed = Date.now() - start;
      console.log(`Created 1000 entities in ${elapsed}ms`);

      // Should complete in under 30 seconds
      expect(elapsed).toBeLessThan(30000);
    });

    it('should read single entity in under 10ms', async () => {
      const created = await repo.create({
        title: 'Test',
        description: 'Test',
        source: { type: 'user-request' },
        acceptanceCriteria: [],
        priority: 'medium',
        category: 'functional',
        status: 'draft',
        votes: 0
      });

      const start = performance.now();
      await repo.findById(created.id);
      const elapsed = performance.now() - start;

      expect(elapsed).toBeLessThan(10);
    });
  });

  describe('Index Consistency', () => {
    it('should maintain index-file consistency', async () => {
      // Create entities
      const entities = [];
      for (let i = 0; i < 5; i++) {
        entities.push(await repo.create({
          title: `Entity ${i}`,
          description: 'Test',
          source: { type: 'user-request' },
          acceptanceCriteria: [],
          priority: 'medium',
          category: 'functional',
          status: 'draft',
          votes: 0
        }));
      }

      // Verify all entities are in index
      for (const entity of entities) {
        expect(await repo.exists(entity.id)).toBe(true);
      }

      // Delete some entities
      await repo.delete(entities[0].id);
      await repo.delete(entities[2].id);

      // Verify deleted entities are not in index
      expect(await repo.exists(entities[0].id)).toBe(false);
      expect(await repo.exists(entities[2].id)).toBe(false);

      // Verify remaining entities still work
      const remaining = await repo.findMany({});
      expect(remaining.total).toBe(3);
    });
  });

  // FIX #30: Add concurrent write tests
  describe('Concurrent Operations', () => {
    it('should handle concurrent creates without corruption', async () => {
      // Create 100 entities concurrently
      const promises = Array(100).fill(0).map((_, i) =>
        repo.create({
          title: `Concurrent Entity ${i}`,
          description: 'Created concurrently',
          source: { type: 'user-request' },
          acceptanceCriteria: [],
          priority: 'medium',
          category: 'functional',
          status: 'draft',
          votes: 0
        })
      );

      const results = await Promise.all(promises);

      // All entities should be created
      expect(results.length).toBe(100);

      // All IDs should be unique
      const ids = results.map(r => r.id);
      expect(new Set(ids).size).toBe(100);

      // Index count should match
      const count = await repo.count({});
      expect(count).toBe(100);
    });

    it('should handle concurrent updates to different entities', async () => {
      // Create entities first
      const entities = await repo.createMany(
        Array(10).fill(0).map((_, i) => ({
          title: `Entity ${i}`,
          description: 'Original',
          source: { type: 'user-request' } as any,
          acceptanceCriteria: [],
          priority: 'medium' as const,
          category: 'functional' as const,
          status: 'draft' as const,
          votes: 0
        }))
      );

      // Update all entities concurrently
      const updatePromises = entities.map((e, i) =>
        repo.update(e.id, { title: `Updated ${i}` })
      );

      const updated = await Promise.all(updatePromises);

      // All updates should succeed
      expect(updated.every((u, i) => u.title === `Updated ${i}`)).toBe(true);
      expect(updated.every(u => u.version === 2)).toBe(true);
    });

    it('should handle mixed concurrent operations', async () => {
      // Create some initial entities
      const initial = await repo.createMany(
        Array(5).fill(0).map((_, i) => ({
          title: `Initial ${i}`,
          description: 'Initial',
          source: { type: 'user-request' } as any,
          acceptanceCriteria: [],
          priority: 'medium' as const,
          category: 'functional' as const,
          status: 'draft' as const,
          votes: 0
        }))
      );

      // Mix of creates, updates, and deletes
      const operations = [
        ...Array(10).fill(0).map(() => repo.create({
          title: 'New',
          description: 'New entity',
          source: { type: 'user-request' } as any,
          acceptanceCriteria: [],
          priority: 'medium' as const,
          category: 'functional' as const,
          status: 'draft' as const,
          votes: 0
        })),
        ...initial.slice(0, 3).map(e => repo.update(e.id, { title: 'Updated' })),
        repo.delete(initial[3].id),
        repo.delete(initial[4].id)
      ];

      await Promise.all(operations);

      // Final count: 5 initial - 2 deleted + 10 new = 13
      const count = await repo.count({});
      expect(count).toBe(13);
    });
  });
});
```

---

## 8. Summary

### 8.1 Architecture Diagram

```
┌─────────────────────────────────────────────────────────────────┐
│                        Domain Layer                              │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │ Services: RequirementService, SolutionService, etc.     │    │
│  └──────────────────────────┬──────────────────────────────┘    │
│                             │ uses                               │
│  ┌──────────────────────────┴──────────────────────────────┐    │
│  │ Interfaces: Repository<T>, LinkRepository, UnitOfWork   │    │
│  └──────────────────────────┬──────────────────────────────┘    │
└─────────────────────────────┼───────────────────────────────────┘
                              │ implements
┌─────────────────────────────┼───────────────────────────────────┐
│                   Infrastructure Layer                           │
│  ┌──────────────────────────┴──────────────────────────────┐    │
│  │              RepositoryFactory                           │    │
│  └──────────────────────────┬──────────────────────────────┘    │
│                             │ creates                            │
│  ┌──────────┬───────────┬───┴───────┬────────────┐              │
│  │  File    │  SQLite   │ Postgres  │   Mongo    │              │
│  │ UoW      │  UoW      │   UoW     │   UoW      │              │
│  └────┬─────┴─────┬─────┴─────┬─────┴──────┬─────┘              │
│       │           │           │            │                     │
│    ┌──┴──┐    ┌───┴───┐   ┌───┴───┐   ┌────┴────┐               │
│    │FS + │    │better-│   │  pg   │   │mongoose │               │
│    │Index│    │sqlite3│   │       │   │         │               │
│    └─────┘    └───────┘   └───────┘   └─────────┘               │
└─────────────────────────────────────────────────────────────────┘
```

### 8.2 Dependencies

```json
{
  "dependencies": {
    "graceful-fs": "^4.2.11",
    "lru-cache": "^10.0.0",
    "proper-lockfile": "^4.1.2",
    "uuid": "^9.0.0"
  },
  "optionalDependencies": {
    "better-sqlite3": "^9.0.0",
    "pg": "^8.11.0",
    "mongoose": "^8.0.0"
  },
  "devDependencies": {
    "@types/graceful-fs": "^4.1.9",
    "@types/node": "^20.0.0",
    "@types/uuid": "^9.0.0",
    "@types/proper-lockfile": "^4.1.4",
    "@types/better-sqlite3": "^7.6.0"
  }
}
```

**Notes:**
- `graceful-fs` provides Windows-compatible atomic file operations (retry on EPERM/EBUSY/EACCES)
- `proper-lockfile` requires `realpath: false` option for Windows compatibility (FIX #16)

### 8.3 Implementation Phases

| Phase | Description | Status |
|-------|-------------|--------|
| **Sprint 9.1** | Core interfaces + Error handling | Ready |
| **Sprint 9.2** | FileRepository + IndexManager + graceful-fs | Ready |
| **Sprint 9.3** | Services integration (backward compatible) | Ready |
| **Sprint 10** | SQLite support | Planned |

### 8.4 Performance Comparison

| Operation | Current (1 file) | New (file/entity) | SQLite |
|-----------|------------------|-------------------|--------|
| Create 1 entity | ~150ms | ~5ms | ~2ms |
| Read 1 entity | ~50ms | ~2ms | ~1ms |
| Update 1 entity | ~150ms | ~5ms | ~2ms |
| List 100 entities | ~50ms | ~20ms | ~5ms |
| Filter by status | ~50ms (full scan) | ~10ms (index) | ~2ms |

> **FIX #32:** *Performance estimates based on typical development hardware with NVMe SSD. Actual performance varies by hardware, workload, and file system. Windows may show higher latencies due to file locking overhead.*

---

## 9. Review Issues Fixed (v2.0 → v2.1)

All 47 issues from the code review have been addressed:

### Critical (8 issues) ✅
- #1-2: Link/IndexManager type incompatibility → `LinkIndexMetadata` + generic `IndexManager<TMetadata>`
- #3: Race condition in cache load → Load deduplication with promise reuse
- #4: Memory leak in index cache → Added `invalidateCache()` method
- #5: SQL `order` reserved keyword → Renamed to `sort_order`
- #6: Deadlock risk → Added `LockManager` for reentrant locks
- #7: Fragile JSON deserialization → Explicit `JSON_COLUMNS` set
- #8: RelationType sync → Documented sync requirement in schema

### High (12 issues) ✅
- #9: Missing SQL indexes → Added `idx_artifacts_related_phase_id`, `idx_artifacts_related_solution_id`
- #10: `project()` return type → Changed to `Pick<T, K>` generic
- #13: Service constructor → Updated with `repositoryFactory` parameter
- #14: Pagination hasMore → Fixed to use actual loaded count
- #15: `createMany` lock contention → Single lock for batch operations
- #16: Windows lockfile → Added `realpath: false` documentation
- #17: Incomplete ALLOWED_COLUMNS → Complete whitelist by entity type
- #19: Index count double-increment → Check `isNew` before increment
- #20: Disk full error handling → Added `ENOSPC` → `DISK_FULL` mapping

### Medium (17 issues) ✅
- #21-37: Error message consistency, magic numbers extraction, validation, documentation improvements

### Low (10 issues) ✅
- #38-47: Comment style, JSDoc for public methods, example error handling

### Second Review Pass (6 additional issues) ✅
- #48: Migration index uses `version` instead of `indexVersion`
- #49: Link migration uses wrong index metadata structure
- #50: Link migration missing `LinkIndex` type import
- #51: Migration `extractRelatedIds` missing array type checks (FIX #33)
- #52-53: Consistency fixes in migration code

### v2.1 → v3.0 Changes ✅

**Focus Refinement:**
- Removed SQLite implementation section (~665 lines) - moved to Sprint 10 planning
- Removed Migration script section (~338 lines) - not relevant for current focus
- Total reduction: ~1000 lines for focused implementation on Repository interface + File implementation

**Windows Compatibility:**
- Added `gracefulRename` using `graceful-fs` library (^4.2.11)
- Fixes EPERM/EBUSY/EACCES errors on Windows (antivirus, indexer, IDE file locks)
- Applied to IndexManager.atomicWrite
- Applied to FileRepository.writeEntityFile

**Entity Field Verification:**
- All fields verified against `src/domain/entities/types.ts`
- Phase.order correctly maps to SQL sort_order (documented in Future Backends)
- Artifact.targets replaces deprecated fileTable (documented)
- Link confirmed as standalone interface (does NOT extend Entity)

**Section Restructuring:**
- Section 5: SQLite Implementation → Future Storage Backends (brief overview)
- Section 7: Data Migration → Removed
- Sections 8-10 renumbered to 7-9

### v3.0 → v3.1 Changes ✅

**Critical Fixes (5 items):**
- **C1:** FilterOperators Type Constraint - Added `Comparable` type, conditional types for `$gt/$gte/$lt/$lte/$contains`
- **C2:** Cache Invalidation Race Condition - Moved cache ops INSIDE lock in `delete()`
- **C3:** createMany Partial Failure Rollback - Track written IDs and cleanup on error
- **C4:** Temp File Name Collision - Use `crypto.randomBytes(8)` (2^64 combinations)
- **C5:** FileUnitOfWork Limitation Warning - Added prominent warning box

**High Fixes (6 items):**
- **H1:** Add `findByMany(ids)` to ReadRepository interface + implementation
- **H2:** Protected Fields in `update()` - Added `UpdateInput<T>` type excluding `id|type|createdAt`
- **H3:** LinkRepository Type Safety - Changed `relationType?: string` to `relationType?: RelationType`
- **H4:** Add `blockingReason` to IndexMetadata
- **H5:** Complete SUMMARY_FIELDS - Added `slug`, `rationale`, `approach`, `selectionReason`, `impactScope`, `supersedes`, `supersededBy`
- **H6:** Index Cache Reference Clear - Added `this.index = null` to `invalidateCache()`

**Medium Fixes (4 items):**
- **M1:** Optimistic Concurrency Control - Added `expectedVersion?` parameter to `update()`
- **M2:** Link Bulk Operations - Added `createMany`, `deleteMany` + `LinkFilter` interface
- **M3:** IsolationLevel Parameter - Added `IsolationLevel` type and parameter to `beginTransaction()`
- **M4:** extractIndexFields Validation - Added warning logs for missing required fields

**Low Fixes (2 items):**
- **L1:** Entity Field Mapping Table - Added comprehensive table in Section 5.4
- **L2:** Missing Entity Fields in Document - Documented all fields from `types.ts`

### v3.1 → v3.2 Changes ✅

**BLOCKER Fix (1 item):**
- **B1:** `blockingReason` field sync - Added `blockingReason?: string` to Phase entity in `types.ts` to match document

**Critical Fixes (4 items):**
- **C1:** Filter<T> Nested Object Limitation - Documented that Filter only works on top-level fields
- **C2:** LinkIndexMetadata Type Safety - Changed `relationType: string` to `relationType: RelationType`
- **C3:** FileLinkRepository Signature Match - Changed `relationType?: string` to `relationType?: RelationType`
- **C4:** Phase Hierarchy Fields in IndexMetadata - Added `parentId`, `order`, `depth`, `progress`, `path`

**High Fixes (3 items):**
- **H5:** Array Membership Check - Added `relatedIds` array filtering in `matchesFilter()`
- **H6:** Missing `votes` Field - Added `votes?: number` to IndexMetadata and extractIndexFields
- **H7:** Missing `artifactType` Field - Added `artifactType?: string` to IndexMetadata and extractIndexFields

**Medium Fixes (2 items):**
- **M2:** Phase Hierarchy Methods - Documented need for `findByParent()`, `findRoots()`, etc.
- **M5:** Version Check Race Condition - Moved `expectedVersion` check INSIDE `withLock()` in `update()`

**Low Fixes (1 item):**
- **L4:** Entity Field Reference - Added `blockingReason?` to Phase field list

### v3.2 → v3.3 Changes ✅

**Critical Review Fixes (6 items):**

**C1 (CRITICAL):** FileLinkRepository Missing Bulk Operations
- Added `createMany()` implementation with single lock and rollback on partial failure
- Added `deleteMany(filter: LinkFilter)` implementation

**M1 (MEDIUM):** Plan/PlanManifest Storage Documentation
- Added Section 4.4 explaining why Plan storage is intentionally outside Repository pattern

**M2 (MEDIUM):** VersionHistory Integration Clarification
- Added warning in Section 6.2 about cleaning up version history on entity deletion

**M3 (MEDIUM):** Solution Evaluation Fields
- Updated Entity Field Reference table to show complete `evaluation` nested fields

**L1 (LOW):** JSON Columns Table
- Added comprehensive table in Section 5.2 listing all fields requiring JSON columns for SQL backends

**L2 (LOW):** Date Typo
- Fixed year from 2024 to 2025

### v3.3 → v3.4 Changes ✅

**Comprehensive Review - 31 Issues Fixed:**

**Critical (CR-C1 to CR-C4):**
- CR-C1: Confirmed selectedAt/selectedBy not in document (no action needed)
- CR-C2: Added `estimatedEffortValue`, `estimatedEffortUnit`, `dueDate` to IndexMetadata for schedule queries
- CR-C3: Added explicit note that `relatedIds` maps `Solution.addressing[]`
- CR-C4: Added `performanceImpact?` to JSON columns table evaluation structure

**High (CR-H1 to CR-H6):**
- CR-H1: Marked `fileTable[]` as **(DEPRECATED)** in JSON columns table
- CR-H3: Added truncation limitation docs in extractIndexFields
- CR-H4: Added Link.metadata validation strategy section
- CR-H5: Added CreateInput metadata handling docs (createdBy, annotations)
- CR-H6: Added `generateSlug()` method to FileRepository

**Medium (CR-M1 to CR-M4):**
- CR-M1: Added PlanManifest.lockVersion vs UnitOfWork clarification table
- CR-M2: Added VersionHistoryService design decision section
- CR-M3: Added QueryOptions.fields limitation docs (top-level only)
- CR-M4: Added blockers[] vs blockingReason clarification with usage example

**Low (CR-L1 to CR-L9):**
- Added complete Status Enum Values table for all entities
- Added Helper Types section with TypeScript interfaces:
  - Tag, Annotation, EffortEstimate, Tradeoff, Milestone, Blocker, ArtifactTarget, AlternativeConsidered
- Added complete RelationType values list with usage annotations

**Architectural (CR-A1 to CR-A5):**
- CR-A1: Added SQL JSON Path Query Strategy with PostgreSQL examples
- CR-A2: Added Recommended SQL Indexes section with CREATE INDEX statements
- CR-A4: Added File Storage Scalability table with recommendations
- CR-A5: Added Index Integrity validation strategy code

**Documentation Structure:**
- Added nested field filtering LIMITATION note after IndexMetadata
- Renumbered Service Integration subsections (6.2-6.5)

---

*Document Version: 3.4 (Comprehensive Review - 31 Issues Fixed)*
*Last Updated: 2025-12-07*
*Changes: 31 fixes from comprehensive review covering Critical (C1-C4), High (H1-H6), Medium (M1-M4), Low (L1-L9), Architectural (A1-A5)*